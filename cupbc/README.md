This package is adapted form several opensource projects:

* https://github.com/bytedance/gpu4pyscf
* https://github.com/hongzhouye/pyscf/tree/rsdf_direct
* https://github.com/pyscf/pyscf
* https://github.com/sunqm/libcint

This package can be imported in python by:

```python
import ByteQC.cupbc as cupbc
```

# File structure

```plaintext
cupbc
├── df
│   ├── ft_ao.py                    # Long-range codes
│   ├── int3c.py                    # Int3cCal class to deal with all ERI generation
│   ├── rsdf_direct_helper.py       # Utilities for range-seperate
│   ├── rsdf_direct_jk.py           # Overload the corresponding functions  for RSDF
│   └── rsdf.py                     # RSDF class
├── dft
│   ├── __init__.py
│   └── krks.py                     # Overload the corresponding functions for KRKS class
├── lib
│   ├── CMakeLists.txt              # Overall makefile
│   ├── config.h                    # Some useful macros
│   ├── cuda_alloc.cuh              # Macros for allocation GPU memory
│   ├── gint                        # Utilies function
│   │   ├── CMakeLists.txt
│   │   └── nr_fill_ao_ints.cu      # Utilies function for ERI calculation
│   ├── gint.h                      # Structures and global macros
│   ├── gpuaft                      # Long-range calculations
│   │   ├── CMakeLists.txt
│   │   ├── ft_ao_bvk.cu            # Driver function for bvk type
│   │   ├── ft_ao_bvk_ext.h         # External declaration for all bvk templates
│   │   ├── ft_ao_bvk_ins1.cu       # Seperate files to enable parallel compile
│   │   ├── ft_ao_bvk_ins2.cu
│   │   ├── ft_ao_bvk_ins3.cu
│   │   ├── ft_ao_bvk_ins4.cu
│   │   ├── ft_ao_bvk_ins5.cu
│   │   ├── ft_ao_bvk_ins6.cu
│   │   ├── ft_ao_bvk_ins7.cu
│   │   ├── ft_ao.cu                # eval_gz & PBCsizeof_env
│   │   ├── ft_ao_GTO.cu            # Driver function for long-range
│   │   ├── ft_ao.h
│   │   ├── ft_ao_latsum.cu         # Driver function for latsum type
│   │   ├── ft_ao_latsum_ext.h      # External declaration for all latsum templates
│   │   ├── ft_ao_latsum_ins1.cu    # Seperate files to enable parallel compile
│   │   ├── ft_ao_latsum_ins2.cu
│   │   ├── ft_ao_latsum_ins3.cu
│   │   ├── ft_ao_latsum_ins4.cu
│   │   ├── ft_ao_latsum_ins5.cu
│   │   ├── ft_ao_latsum_ins6.cu
│   │   ├── ft_ao_latsum_ins7.cu
│   │   ├── ft_ao_template.cu       # Template definations
│   │   └── time_balance_helper.jl  # Unity to balance the build time for different instances
│   └── pbc_gpu                     # Short-range calculations, ERI
│       ├── CMakeLists.txt
│       ├── fill_int2e.cu           # Launch the kernel
│       ├── fill_int2e.cuh
│       ├── fill_ints_sr.c          # Driver function CPU side
│       ├── fill_ints_sr.cu         # Driver function GPU side
│       ├── fill_ints_sr.h
│       ├── g2e.cu                  # Integral functiond
│       ├── get_Rcuts.cu            # Prescreen
│       ├── get_Rcuts.cuh           # Prescreen
│       ├── linalg.cuh              # Uilties for contraction
│       ├── roots_for_x0.cuh        # Rys root data
│       ├── rys_roots.cu            # Get Rys root
│       ├── rys_xw.cuh              # Rys root data
│       ├── util.cu                 # Helper functions
│       ├── util.cuh
│       └── write_int3c.cu          # Write g/gout to eri
├── test                            # Test units
│   ├── config.txt                  # The config file for test unit, if not exists, will be generated by `getconfig.py` automatically
│   ├── dumpj3c.py                  # Dump j3c into file follow the format of CPU version
│   ├── eri_cpu.py                  # Calculate ERI with CPU version RSDF
│   ├── eri.py                      # Test the correctness of GPU RSDF with CPU one
│   ├── getconfig.py                # Get config for test unit
│   ├── krks.py                     # Test correctness of vj+vxc HF
│   ├── large.py                    # Test for large systems
│   ├── rsdf.py                     # Test correctness of vj+vk HF
│   └── vjvk.py                     # Test correctness of vj and vk
├── __init__.py                     # Overload the corresponding functions for KRHF class
├── int3c2e.py                      # _VHFOpt class to prepare the basis for int3c
├── setup.py                        # python scripts to build this package
└── README.md
```

Some comments:

+ The global variable `Mg` in `multigpu.py` controls the multi-GPU behaviours of the whole package.
+ `config.txt` is not included by default, and will be generated with default values on first test. `config.txt` will infect all test units excepet for `large.py`.
+ ERI test, i.e. `eri_cpu.py` and `eri.py` will need another package `CPU_RSDF`.
+ `dumpj3c.py`, `eri.py`, and `vjvk.py` are designed for small systems. Running such tests on large system may cause an out-of-memory error.
+ The `*.cu` files with different number in folder `lib/gpuaft` instantiate different instantes, which enable parallel compile when `make -j`, thus save the compiletation time.

# Functionality

Most functionality interfaces are implemented in the class `RSDF`. There are a parameter should pay attention to when instantiating a `RSDF` instance (can also be changed after instantiating but before calculation).

+ `prescreen_mask`: This parameter determines the prescreen level of short-range ERI calculations. `prescreen_mask=2` is the default settings and means prescren the basis and the aux basis; `1` means only prescren the basis. `0` means no prescreen. The prescreen would greatly reduce the computational burden while maintaining errors negligible, thus `2` is the recommended value.

There are one parameters should be set before building:

+ `omega`: This controls the ratio of short-range and long-range. The default value is `0.1`.

There are one parameters should be set before calculating:

+ `parallel_vxc`: The default value is `True`, means the calcualtion of `vxc` and `vj` will be paralleled.

One can always refer to the test units in `GPU_RSDF/pyscf/cupbc/test` folder to learn how to run this package quickly.

## On-fly Generate ERI

Sometimes one only needs the ERI to do calculations, e.g. transforming the ERI of the whole system into embedding purities. For this purpose one can use the `j3c_func` functions of `RSDF` class:

```python
j3c = rsdf.j3c_func(kpts, kpts_band=None, auxflag=2, j3c_mask=3)
```

`auxflag`: It controls whether the j2c or cart2sph coeff should also be combined. `auxflag=0` will return ERI in cart type. `auxflag=1` will apply the cart2sph coeff and return the ERI in sph form. It should be noticed that the basis will always be return in `cart` type. `auxflag=2` will apply the j2c also. The j2c integrals will be only calculated once on CPU and automatically reused. If one wants to calculate `j2c` in advance, access the `rsdf.int3c.j2c` before the ERI calculation.

`j3c_mask`: ERI calculation contains three parts: short_range, remove_g0 and long-range. `j3c_mask` can turn off the latter two and only used for debugging.

Return value: `j3c` is a function takes only one parameters `cp_ij_id`. It returns the i slice `si`, j slice `sj`, and corresponding ERI slices `eris`, such that `eris = ERIS[:, si, sj, :]` with ERIS the total eri. The total number of slices is `rsdf.int3c.vhfopt.ncptype`.

After the ERI calculations the occupied GPU memory should be freed by calling `rsdf.clean_j3c()`.

## Save ERI into file

The original `pyscf` in default saves the ERI into file when the `RSDF` class is built. However, the GPU calculations currently only support `cart`-type basis, and `sph`-type is transferred after the eri slices is calculated, which makes following the CPU file format an inefficient task. Thus we provide two functions to save the ERI into file: `dump_j3c` following the CPU file format and `save_j3c` not. However, the efficiency of `dump_j3c` is not good and needs more memory.

```python
def dump_eri(self, cderi_file, kpts=None, buflen=None)
```

`buflen`: This determines the slice size of the ERI, each slice in file is shaped with (buflen\*naoaux). In CPU it is determined by CPU memory. In `GPU_RSDF` it is manually set and equals tp nao\*nao by default.

```python
def save_j3c(self, cderi_file, kpts=None, jktype='k', auxflag=2)
```

`jktype`: It should be `'j'` or `'k'`. `jktype='k'` will calculate the ERIS with all kpts, which is usually used for `vk` calculations. For `vj`, only diagnoal kpts are needed, thus simplify from `nkpts*nkpts` to `nkpts`.

`auxflag`: It controls whether the j2c or cart2sph coeff should also be combined. `auxflag=0` will return ERI in cart type. `auxflag=1` will apply the cart2sph coeff and return the ERI in sph form. It should be noticed that the basis will always be return in `cart` type. `auxflag=2` will apply the j2c also. The j2c integrals will be only calculated once on CPU and automatically reused. If one wants to calculate `j2c` in advance, access the `rsdf.int3c.j2c` before the ERI calculation.

The format is not suitable for CPU calculations on `pyscf`. However, this file can be passed into `RSDF` when building:

```python
rsdf.build(cderi="/tmp/a.dat")
```

By this, the eri file is used for later calculations.

## Mean-field calculation

There are two types of mean-field calculation is supported: DFT with `vj+vxc` and Hartree-Fock with `vj+vk`. By default, the eri are calculated on-fly, which means the default parameter when building `RSDF` is `with_j3c=False`.  One can pre-calculate ERI by calling `mf.with_df.build(with_j3c=True, jktype='k')` before kernel function. If one only needs `vj` without `vk`, `jktype=j` is enough, otherwise `jktype=j` is needed. The calculation of `jktype=k` is a supee set of that of `jktype=j`, and calculating `vj` with pre-calculated `jktype=k` file is supported.

### vj+vxc

A typical calculation is like:

```python
from byteqc.cupbc import scf as pscf
mf = scf.KRKS(cell, kpts=kpts).rs_density_fit(**kargs)
mf.xc = xc
mf.verbose = verbose
mf.max_memory = 700000
mf.with_df.max_memory = 700000
mf.max_cycle = 100
# mf.with_df.build(with_j3c=True, jktype='j')
mf.kernel()
```

### vj+vk

A typical calculation is like:

```python
from byteqc.cupbc import scf as pscf
mf = scf.KRHF(cell, kpts=kpts).rs_density_fit(**kargs)
mf.verbose = verbose
mf.max_memory = 700000
mf.with_df.max_memory = 700000
mf.max_cycle = 100
mf.with_df.omega = 0.1
# mf.with_df.build(with_j3c=True, jktype='k')
mf.kernel()
```

## MultiGPU support

`GPU_RSDF` will do the calculation using all GPUs by default. This behaviour can be controlled by the global variables `Mg`. Running following codes

```python
import byteqc.cupbc.lib.multigpu as multigpu
multigpu.Mg = multigpu.Gpus(3)
```

will force `GPU_RSDF` use the first three GPUs.

One can also specify which GPUs to use:

```python
import byteqc.cupbc.lib.multigpu as multigpu
multigpu.Mg = multigpu.Gpus([3,2,4])
```

We use threads to drive different GPUs, thus when using x GPUs, x CPUs will also needed.
